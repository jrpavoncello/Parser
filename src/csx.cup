/***
 *
 * This Is A Java CUP Specification For CSX-lite, a Small Subset
 * of The CSX Language,  Prepared by Charles Fischer.
 *
 ***/

/* Preliminaries to set up and use the scanner.  */

import java_cup.runtime.*;
parser code {:
 public void syntax_error(Symbol cur_token)
     {
 	  report_error("CSX syntax error at line "+
			String.valueOf(((CSXToken)cur_token.value).linenum),
			null);
     }
:};
init with {:              :};
scan with {: return Scanner.next_token(); :};

/* Terminals (tokens returned by the scanner). */
terminal CSXToken     		STRLIT, rw_FLOAT, rw_WHILE, rw_BOOL, LBRACKET, rw_IF, rw_CONTINUE, 
							rw_FALSE, LPAREN, SEMI, rw_PRINT, rw_TRUE, RPAREN, NOT, INTLIT, 
							rw_VOID, LT, rw_CONST, COMMA, INC, rw_ELSE, GEQ, rw_READ, rw_INT, 
							RBRACKET, COR, rw_CLASS, rw_RETURN, EQ, FLOATLIT, ASG,
							CHARLIT, COLON, LBRACE, rw_CHAR, RBRACE, CAND, LEQ, rw_BREAK, DEC, GT, 
							NOTEQ, IDENTIFIER, SLASH, TIMES, PLUS, MINUS, rw_ENDIF, rw_FOR;

/* Non terminals */
non terminal classNode     		prog;
non terminal memberDeclsNode	memberdecls;
non terminal fieldDeclsNode    	fielddecls;
non terminal methodDeclsNode	methoddecls;
non terminal nullNode	     	optionalsemi;
non terminal nullNode	     	methoddecl;
non terminal nullNode	     	argdecls;
non terminal nullNode	     	argdecl;
non terminal declNode	 		fielddecl;
non terminal nullNode	     	stmts;
non terminal nullNode	     	stmt;
non terminal nullNode	     	type;
non terminal nullNode	     	args;
non terminal nullNode	     	readlist;
non terminal nullNode	     	printlist;
non terminal nullNode	     	expr;
non terminal nullNode	     	term;
non terminal nullNode	     	factor;
non terminal nullNode	     	pri;
non terminal nullNode	     	unary;
non terminal nullNode	     	unit;
non terminal nullNode	     	name;
non terminal nullNode	     	update;
non terminal identNode			ident;

start with prog;

prog			::= rw_CLASS:c ident:id LBRACE memberdecls:m RBRACE
				{:
					RESULT = new classNode(id, m, c.linenum, c.colnum);
				:}
			;
		
memberdecls		::= fielddecl:f memberdecls:memDecls
				{:
					fieldDeclsNode newFields = 
					new fieldDeclsNode(f, memDecls.fields, f.linenum, f.colnum);
					RESULT = new memberDeclsNode(newFields, memDecls.methods, 
					memDecls.linenum, memDecls.colnum);
				:}
				
				| methoddecls:methDecls
				{:
					RESULT = new memberDeclsNode(fieldDeclsNode.NULL,
					methDecls, methDecls.linenum, methDecls.colnum);
				:}
			;
		
fielddecls		::= fielddecl fielddecls
				| /* NULL */
			;
			
methoddecls		::= methoddecl methoddecls
				| /* NULL */
			;

optionalsemi	::= SEMI
				| /* NULL */
			;
				
methoddecl		::= rw_VOID ident LPAREN RPAREN LBRACE fielddecls stmts RBRACE optionalsemi
				| rw_VOID ident LPAREN argdecls RPAREN LBRACE fielddecls stmts RBRACE optionalsemi
				| type ident LPAREN RPAREN LBRACE fielddecls stmts RBRACE optionalsemi
				| type ident LPAREN argdecls RPAREN LBRACE fielddecls stmts RBRACE optionalsemi
				| argdecl COMMA argdecls
				| argdecl
			;
			
argdecls		::= argdecl COMMA argdecls
				| argdecl
			;

argdecl			::= type ident
				| type ident LBRACKET RBRACKET
			;

fielddecl		::= type ident SEMI
				| type ident ASG expr SEMI
				| type ident LBRACKET INTLIT RBRACKET SEMI
				| rw_CONST ident ASG expr SEMI
			;
			
stmts			::= stmt stmts
				| stmt
			;
			
stmt			::= rw_IF LPAREN expr RPAREN stmt rw_ENDIF
				| rw_IF LPAREN expr RPAREN stmt rw_ELSE stmt rw_ENDIF
				| rw_WHILE LPAREN expr RPAREN stmt
				| ident COLON rw_WHILE LPAREN expr RPAREN stmt
				| rw_READ LPAREN readlist RPAREN SEMI
				| rw_PRINT LPAREN printlist RPAREN SEMI
				| ident LPAREN RPAREN SEMI
				| ident LPAREN args RPAREN SEMI
				| update SEMI
				| rw_RETURN SEMI
				| rw_RETURN expr SEMI
				| rw_BREAK ident SEMI
				| rw_CONTINUE ident SEMI
				| LBRACE fielddecls stmts RBRACE optionalsemi
				| rw_FOR LPAREN name ASG expr SEMI expr SEMI update RPAREN stmt
			;
			
			
update		::= ident INC 
				| INC ident 
				| ident DEC 
				| DEC ident 
				| name ASG expr
			;
		
type			::= rw_INT
				| rw_CHAR
				| rw_BOOL
				| rw_FLOAT
			;
			
args			::= expr COMMA args
				| expr
			;
				
readlist		::= name COMMA readlist
				| name
			;
			
printlist		::= expr COMMA printlist
				| expr
			;
			
expr			::= expr COR term
				| expr CAND term
				| term
			;
			
term			::= factor LT factor
				| factor GT factor
				| factor LEQ factor
				| factor GEQ factor
				| factor EQ factor
				| factor NOTEQ factor
				| factor
			;
			
factor			::= factor PLUS pri
				| factor MINUS pri
				| pri
			;

pri				::= pri TIMES unary
				| pri SLASH unary
				| unary
			;
			
unary			::= NOT unary
				| LPAREN type RPAREN unary
				| unit
			;
			
unit			::= name
				| ident LPAREN RPAREN
				| ident:id LPAREN args:ar RPAREN
				| INTLIT:il
				{: RESULT = new strLitNode(il.intValue,
				il.linenum, il.colnum);
				:}
				| CHARLIT:cl
				{: RESULT = new floatLitNode(cl.charValue,
				cl.linenum, cl.colnum);
				:}
				| FLOATLIT:fl
				{: RESULT = new floatLitNode(fl.floatValue,
				fl.linenum, fl.colnum);
				:}
				| STRLIT:sl
				{: RESULT = new strLitNode(sl.stringValue,
				sl.linenum, sl.colnum);
				:}
				| rw_TRUE:t
				{: RESULT = new trueNode(
				t.linenum, t.colnum);
				:}
				| rw_FALSE:f
				{: RESULT = new falseNode(
				f.linenum, f.colnum);
				:}
				| LPAREN expr RPAREN
				
			;
			
ident			::= IDENTIFIER:i
				{: 
				CSXIdentifierToken identToken = (CSXIdentifierToken)i;
				RESULT = new identNode(identToken.identifierText,
					 identToken.linenum,identToken.colnum); :}
			;
			
name			::= 
				| ident:i
				{: new nameNode(i, exprNode.NULL, i.linenum,i.colnum); :}
				| ident:i LBRACKET expr:e RBRACKET
				{: RESULT = new nameNode(i, e, i.linenum,i.colnum); :}	
			;

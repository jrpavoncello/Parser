/***
 *
 * This Is A Java CUP Specification For CSX-lite, a Small Subset
 * of The CSX Language,  Prepared by Charles Fischer.
 *
 ***/

/* Preliminaries to set up and use the scanner.  */

import java_cup.runtime.*;
parser code {:
 public void syntax_error(Symbol cur_token)
     {
 	  report_error("CSX syntax error at line "+
			String.valueOf(((CSXToken)cur_token.value).linenum),
			null);
     }
:};
init with {:              :};
scan with {: return Scanner.next_token(); :};

/* Terminals (tokens returned by the scanner). */
terminal CSXToken     		STRLIT, rw_FLOAT, rw_WHILE, rw_BOOL, LBRACKET, rw_IF, rw_CONTINUE, 
							rw_FALSE, LPAREN, SEMI, rw_PRINT, rw_TRUE, RPAREN, NOT, INTLIT, 
							rw_VOID, LT, rw_CONST, COMMA, INC, rw_ELSE, GEQ, rw_READ, rw_INT, 
							RBRACKET, COR, rw_CLASS, rw_RETURN, EQ, FLOATLIT, ASG,
							CHARLIT, COLON, LBRACE, rw_CHAR, RBRACE, CAND, LEQ, rw_BREAK, DEC, GT, 
							NOTEQ, IDENTIFIER, SLASH, TIMES, PLUS, MINUS, rw_ENDIF, rw_FOR;

/* Non terminals */
non terminal classNode     		prog;
non terminal memberDeclsNode	memberdecls;
non terminal fieldDeclsNode    	fielddecls;
non terminal methodDeclsNode	methoddecls;
non terminal nullNode	     	optionalsemi;
non terminal methodDeclNode    	methoddecl;
non terminal argDeclsNode	    argdecls;
non terminal argDeclNode	    argdecl;
non terminal declNode	 		fielddecl;
non terminal stmtsNode	     	stmts;
non terminal stmtNode	     	stmt;
non terminal typeNode	     	type;
non terminal argsNode	     	args;
non terminal readNode	     	readlist;
non terminal printNode	     	printlist;
non terminal exprNode	     	expr;
non terminal nullNode	     	term;
non terminal nullNode	     	factor;
non terminal nullNode	     	pri;
non terminal nullNode	     	unary;
non terminal nullNode	     	unit;
non terminal nullNode	     	name;
non terminal stmtNode	     	update;
non terminal identNode			ident;
non terminal voidTypeNode		void;
non terminal intLitNode			intlit;

start with prog;

prog			::= rw_CLASS:c ident:id LBRACE memberdecls:m RBRACE
				{:
					RESULT = new classNode(id, m, c.linenum, c.colnum);
				:}
			;
		
memberdecls		::= fielddecl:f memberdecls:memDecls
				{:
					fieldDeclsNode newFields = 
					new fieldDeclsNode(f, memDecls.fields, f.linenum, f.colnum);
					RESULT = new memberDeclsNode(newFields, memDecls.methods, 
					memDecls.linenum, memDecls.colnum);
				:}
				
				| methoddecls:methDecls
				{:
					RESULT = new memberDeclsNode(fieldDeclsNode.NULL,
					methDecls, methDecls.linenum, methDecls.colnum);
				:}
			;
		
fielddecls		::= fielddecl:f fielddecls:fDecls
				{:
					RESULT = new fieldDeclsNode(f, fDecls, f.linenum, f.colnum);
				:}
				| /* NULL */
				{:
					RESULT = fieldDeclsNode.NULL;
				:}
			;
			
methoddecls		::= methoddecl:m methoddecls:mDecls
				{:
					RESULT = new methodDeclsNode(m, mDecls, m.linenum, m.colnum);
				:}
				| /* NULL */
				{:
					RESULT = methodDeclsNode.NULL;
				:}
			;

optionalsemi	::= SEMI
				| /* NULL */
			;
				
methoddecl		::= void:v ident:id LPAREN RPAREN LBRACE fielddecls:fDecls stmts:s RBRACE optionalsemi
				{:
					RESULT = new methodDeclNode(id, argDeclsNode.NULL, v, fDecls, s, v.linenum, v.colnum);
				:}
				| void:v ident:id LPAREN argdecls:aDecls RPAREN LBRACE fielddecls:fDecls stmts:s RBRACE optionalsemi
				{:
					RESULT = new methodDeclNode(id, aDecls, v, fDecls, s, v.linenum, v.colnum);
				:}
				| type:t ident:id LPAREN RPAREN LBRACE fielddecls:fDecls stmts:s RBRACE optionalsemi
				{:
					RESULT = new methodDeclNode(id, argDeclsNode.NULL, t, fDecls, s, t.linenum, t.colnum);
				:}
				| type:t ident:id LPAREN argdecls:aDecls RPAREN LBRACE fielddecls:fDecls stmts:s RBRACE optionalsemi
				{:
					RESULT = new methodDeclNode(id, aDecls, t, fDecls, s, t.linenum, t.colnum);
				:}
			;

void			::= rw_VOID:v
				{:
					RESULT = new voidTypeNode(v.linenum, v.colnum);
				:}
			;
			
argdecls		::= argdecl:a COMMA argdecls:aDecls
				{:
					RESULT = new argDeclsNode(a, aDecls, a.linenum, a.colnum);
				:}
				| argdecl:a
				{:
					RESULT = new argDeclsNode(a, argDeclsNode.NULL, a.linenum, a.colnum);
				:}
			;

argdecl			::= type:t ident:id 
				{:
					RESULT = new valArgDeclNode(id, t, t.linenum, t.colnum);
				:}
				| type:t ident:id LBRACKET RBRACKET
				{:
					RESULT = new arrayArgDeclNode(id, t, t.linenum, t.colnum);
				:}
			;

fielddecl		::= type:t ident:id SEMI
				{:
					RESULT = new varDeclNode(id, t, exprNode.NULL, t.linenum, t.colnum);
				:}
				| type:t ident:id ASG expr:e SEMI
				{:
					RESULT = new varDeclNode(id, t, e, t.linenum, t.colnum);
				:}
				| type:t ident:id LBRACKET intlit:lit RBRACKET SEMI
				{:
					RESULT = new arrayDeclNode(id, t, lit, t.linenum, t.colnum);
				:}
				| rw_CONST:c ident:id ASG expr:e SEMI
				{:
					RESULT = new constDeclNode(id, e, c.linenum, c.colnum);
				:}
			;
			
stmts			::= stmt stmts
				| stmt
			;
			
stmt			::= rw_IF:i LPAREN expr:e RPAREN stmt:s rw_ENDIF
				{:
					RESULT = new ifThenNode(e, s, stmtNode.NULL, i.linenum, i.colnum); 
				:}
				| rw_IF:i LPAREN expr:e RPAREN stmt:s1 rw_ELSE stmt:s2 rw_ENDIF
				{:
					RESULT = new ifThenNode(e, s1, s2, i.linenum, i.colnum); 
				:}
				| rw_WHILE:w LPAREN expr:e RPAREN stmt:s
				{:
					RESULT = new whileNode(exprNode.NULL, e, s, w.linenum, w.colnum); 
				:}
				| ident:id COLON rw_WHILE LPAREN expr:e RPAREN stmt:s
				{:
					RESULT = new whileNode(id, e, s, id.linenum, id.colnum); 
				:}
				| rw_READ:r LPAREN readlist:rList RPAREN SEMI
				{:
					RESULT = rList;
				:}
				| rw_PRINT LPAREN printlist:pList RPAREN SEMI
				{:
					RESULT = pList;
				:}
				| ident:id LPAREN RPAREN SEMI
				{:
					RESULT = new callNode(id, argsNode.NULL, id.linenum, id.colnum); 
				:}
				| ident:id LPAREN args:a RPAREN SEMI
				{:
					RESULT = new callNode(id, a, id.linenum, id.colnum); 
				:}
				| update:u SEMI
				{:
					RESULT = u;
				:}
				| rw_RETURN:r SEMI
				{:
					RESULT = new returnNode(exprNode.NULL, r.linenum, r.colnum); 
				:}
				| rw_RETURN:r expr:e SEMI
				{:
					RESULT = new returnNode(e, r.linenum, r.colnum); 
				:}
				| rw_BREAK:b ident:id SEMI
				{:
					RESULT = new breakNode(id, b.linenum, b.colnum); 
				:}
				| rw_CONTINUE:c ident:id SEMI
				{:
					RESULT = new continueNode(id, c.linenum, c.colnum); 
				:}
				| LBRACE:lb fielddecls:fDecls stmts:s RBRACE optionalsemi
				{:
					RESULT = new blockNode(fDecls, s, lb.linenum, lb.colnum);
				:}
				| rw_FOR:f LPAREN ident:id ASG expr:initExpr SEMI expr:condExpr SEMI update:upExpr RPAREN stmt:s
				{:
					RESULT = new forNode(id, initExpr, condExpr, upExpr, s, f.linenum, f.colnum);
				:}
			;
			
			
update		::= ident INC 
				| INC ident 
				| ident DEC 
				| DEC ident 
				| name ASG expr
			;
		
type			::= rw_INT
				| rw_CHAR
				| rw_BOOL
				| rw_FLOAT
			;
			
args			::= expr COMMA args
				| expr
			;
				
readlist		::= name COMMA readlist
				| name
			;
			
printlist		::= expr COMMA printlist
				| expr
			;
			
expr			::= expr COR term
				| expr CAND term
				| term
			;
			
term			::= factor LT factor
				| factor GT factor
				| factor LEQ factor
				| factor GEQ factor
				| factor EQ factor
				| factor NOTEQ factor
				| factor
			;
			
factor			::= factor PLUS pri
				| factor MINUS pri
				| pri
			;

pri				::= pri TIMES unary
				| pri SLASH unary
				| unary
			;
			
unary			::= NOT unary
				| LPAREN type RPAREN unary
				| unit
			;
			
unit			::= name
				| ident LPAREN RPAREN
				/* fctCallNode */
				| ident:id LPAREN args:ar RPAREN
				/* fctCallNode */
				| intlit:il
				{: 
					RESULT = il;
				:}
				| CHARLIT:cl
				{:
					RESULT = new floatLitNode(cl.charValue,
					cl.linenum, cl.colnum);
				:}
				| FLOATLIT:fl
				{:
					RESULT = new floatLitNode(fl.floatValue,
					fl.linenum, fl.colnum);
				:}
				| STRLIT:sl
				{:
					RESULT = new strLitNode(sl.stringValue,
					sl.linenum, sl.colnum);
				:}
				| rw_TRUE:t
				{:
					RESULT = new trueNode(
					t.linenum, t.colnum);
				:}
				| rw_FALSE:f
				{:
					RESULT = new falseNode(
					f.linenum, f.colnum);
				:}
				| LPAREN expr RPAREN
				
			;
			
ident			::= IDENTIFIER:i
				{: 
					CSXIdentifierToken identToken = (CSXIdentifierToken)i;
					RESULT = new identNode(identToken.identifierText,
						 identToken.linenum,identToken.colnum);
				 :}
			;
			
name			::= ident:id
				{:
					RESULT = new nameNode(id, exprNode.NULL, i.linenum,i.colnum);
				:}
				| ident:id LBRACKET expr:e RBRACKET
				{:
					RESULT = new nameNode(id, e, i.linenum,i.colnum);
				:}	
			;
			
intlit			::= INTLIT:i
				{:
					RESULT = new intLitNode(((CSXIntLitToken)i).intValue, i.linenum, i.colnum);
				:}
			;
